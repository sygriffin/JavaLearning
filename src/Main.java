import javax.annotation.processing.SupportedOptions;import javax.print.DocFlavor;import java.math.BigDecimal;public class Main {    public static void main(String[] args) {        int age = 10;        age += 10;        System.out.println(age);        char c = '中';        System.out.println(c);        boolean compare = false;        System.out.println(compare);        compare = true;        System.out.println(compare);        if (compare) {            System.out.println(1);        } else  {            System.out.println(0);        }//        String astr = "你好，";//        String bStr = "Java";        String cStr = "JAVA" + "Hello";        System.out.println(cStr);        int i = 5;        int j = 5;        int k = i++ + j;        i = 5;        j = 5;        int l = ++i + j;        System.out.println(k);        System.out.println(l);        STATUS status;        int result = 74;        if (result >= 0 && result < 60){            status = STATUS.STATUS_cha;            System.out.println(status);        } else if (result >= 60 && result < 70){            status = STATUS.STATUS_zhong;            System.out.println(status);        } else if (result >= 70 && result < 85){            status = STATUS.STATUS_liang;            System.out.println(status);        } else if (result >= 85 && result < 100){            status = STATUS.STATUS_you;            System.out.println(status);        } else {        }        for (int z = 0; z< 10 ; z++) {            System.out.println(z);        }        int x = 0;        while (x<10) {            System.out.println(x++);        }        Dog dog = new Dog();        dog.bark();        A classA = new A("aaa");        A classA1 = new A();        classA.funA();        classA.funA(6);        Person p = new Person();        p.name = "lisi";        p.talk();        Person.i = 6;//static静态成员变量可以使用类名调用, 生成的person对象会公用这个成员变量        Person q = new Person();        System.out.println(Person.i);        Person.fun();        Student student = new Student();        student.name = "zhangsan1";        student.age = 17;        student.eat();        Student student2 = new Student("wangwu1",14,4);        Class1 classType = new Class1();        BigDecimal a = BigDecimal.valueOf(100);        student2.eat();        student2.talk();        p.eat();        /*****************************************************************/        //特殊的抽象类        //面向对象的多态性        USBPhone phone = new USBPhone();        USB usb = phone;        usb.USBread();        usb.USBwrite();        WiFi wifi = phone;        wifi.openWifi();        wifi.closeWifi();        //异常 -- 中断了正常的指令流的事件        //此时编译是没有问题的 -- 运行过程中产生的        System.out.println("1111111111");        try {            System.out.println("3333333333");            int excp = 1/0;//之下的都不执行了，去了catch            System.out.println("4444444444");        } catch (Exception e){            System.out.println("5555555555");            e.printStackTrace();            System.out.println("6666666666");        }        ///异常的后面的代码不会继续执行了        //uncheck Exception        System.out.println("7777777777");        ///JDK提供异常类//        Throwable --> Exception --> RuntimeException//                  --> Error        //多线程        /**        //生成一个线程对象        FirstThread firstThread = new FirstThread();        //启动线程 --> 必须用start        firstThread.start();        //firstThread.run(); //-->❎错误写法        //主线程 -- 启动线程对象线程 -- 垃圾回收线程        for (int iii = 0;iii< 100; iii++) {            System.out.println("Main --> " +iii);        }        //两个循环运行在不同的线程中 --> 无规律的运行，没谱        //实现线程的第二种方法 -- Runnable        */        /**        //生成runnable（接口对象）        RunnableImpl ri = new RunnableImpl();        //生成thread对象，并传入Runnable对象        Thread athread = new Thread(ri);        //通知thread执行        System.out.println("优先级："+athread.getPriority());        athread.setPriority(Thread.MAX_PRIORITY);        System.out.println("优先级："+athread.getPriority());        //最大优先级10，最小1        athread.start();        */        //都复写了run方法        //实际开发中更倾向于第二种方法        //线程简单的控制方法 -- sleep() || yield() --> 自动让出cpu资源（但不一定谁抢占cpu）        //设置线程优先级 -- getPriority  setPriority        //优先级越高的线程，优先执行的概率越大        //线程的同步 -- 多线程的数据同步        RunnableImpl ri1 = new RunnableImpl();        Thread tt1 = new Thread(ri1);        Thread tt2 = new Thread(ri1);        tt1.setName("线程1");        tt2.setName("线程2");        tt1.start();        tt2.start();    }    public enum STATUS {        STATUS_you,STATUS_liang,STATUS_zhong,STATUS_cha    }    static class Dog {        //如果一个方法中有与成员变量同名的局部变量，则方法中访问的是局部变量，而不是成员变量        public String color;        String name;        Integer age;        void bark (){            System.out.println("wang wang");        }    }}class A {    String name;    A() {}    A(String aName){        name = aName;    }    void funA() {        System.out.println("empty func");    }    void funA(int i) {        System.out.println(i);    }}//this 关键字(对象本身，相当于OC-self)class Person {    String name;    int age;    String address;    Person() {    }    Person(String name , int age) {        this();        this.name = name;        this.age  = age;    }    Person(String name , int age, String address) {        //直接调用本类中的构造函数，this这条语句必须在第一句        this(name, age);        this.address = address;    }    //static关键字    static  int i;    //静态函数    static  void  fun() {//        静态函数中不能引用非静态的，不存在类的对象//        System.out.println("My name is " + this.name);        System.out.println("静态函数");    }    void talk() {        //使用成员变量使用this，不然默认为传入参数        System.out.println("My name is " + this.name);    }    //静态代码块 -- 在装载这个类的时候执行，无需调用，实际上用的也不多    static  {        System.out.println("static block");    }    void eat() {        System.out.println("eat");    }}//继承 -- 优化代码的一种思路//为什么子类中必须调用父类的构造函数，赋值（无法继承构造函数，只能调用）class Student extends Person {    int grade;    String score;    Student() {    }    Student (String name, int age, int grade) {        super(name,age);        this.grade = grade;    }    //Java 不支持多继承    //override 复写    @Override    void talk() {        super.talk();        System.out.println("garde is "+grade);    }    //复写（重写）    @Override    void eat() {//        super.eat();        System.out.println("student eat");    }    void study() {        System.out.println("Student study");    }}